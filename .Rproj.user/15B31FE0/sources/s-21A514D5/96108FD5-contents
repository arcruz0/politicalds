# Data Visualization {#dataviz}

*Soledad Araya*^[Institute of Political Science, Pontificia Universidad Católica de Chile. E-mail: snaraya\@uc.cl.]

### Suggested readings {-}

- Henshaw, A. L. and Meinke, S. R. (2018). Data Analysis and Data Visualization as Active Learning in Political Science. *Journal of Political Science Education,* 14(4):423–439.

- Kastellec, J. P. and Leoni, E. L. (2007). Using Graphs Instead of Tables in Political Science. *Perspectives on Politics,* 5(4).

- Tufte, E. R. (2006). *Beautiful Evidence.* Graphics Press, Cheshire, Conn.

### Packages you need to install {-}

- `tidyverse` [@R-tidyverse], `politicalds` [@R-politicalds], `ggrepel` [@R-ggrepel].

## Why visualize my data?

You have already learned to use the commands from `tidyverse`, and you probably want to dive in the world of graphs, and apply all you have been learning to your own dataset. With `tidyverse` and `ggplot2`, data management becomes an easy task, but there are a few steps you need to go through before writing your code. For example, knowing your variables. Are they continuous or categorical variables? When they are categorical, do they have two or more levels? Moreover, those levels, are they in order or not? These are not the only questions you have to consider. It appears an easy task, but if you do not consider this step in your work with `ggplot2` things can turn bad pretty quickly. Fun examples of this can be found in [accidental aRt](https://twitter.com/accidental__aRt).

Quick question: Why represent our data graphically?

First, I know that many of us are interested in representing our data graphically because it is an attractive way of doing it. However, having a good or bad sense of aesthetics does not mean a a lot if our data is not clear. Thus, it is necessary to *understand* what we want to express, which can be a hard task if we do not reflect on why are we doing such types of representation. Sometimes, we can use tables to summarize quantities and/or patterns, but big data management nowadays makes this a complex and inefficient task. Therefore, let's return to the main question: why visualize? Why not simply make tables that express what we want to say? Through data visualization we can understand other types of problems that numbers on their own cannot show. By visualizing, we want to explore and *comprehend* our data. Also, graphing can help us with the interpretation of patterns, tendencies, distributions, and better communicating these to our readers. 

```{r florence-nightingale, echo=F, out.width="40%", fig.cap=" Statistician Florence Nightingale (1820-1910)."}
knitr::include_graphics("00-images/dataviz/florence_nightingale.jpg")
```

Florence Nightgale (1820-1910) was a nurse and statistician who helped reorganize the administration of civic and military hospitals in Great Britain (Figure \@ref(fig:florence-nightingale)). She, with the help of a team, managed to make a record of the deaths and diseases in military hospitals during the Crimean War. For her surprise, the vast majority of deaths were avoidable, and the main reason behind them were the poor conditions of the health system. One of her reports for the British government was the diagram in Figure \@ref(fig:mortality-nightingale1).

```{r mortality-nightingale1, echo=F, out.width="60%", fig.cap= "Diagram of the causes of death in the British army."}
knitr::include_graphics("00-images/dataviz/nightingale_mortality.jpg")
```

In dark gray are highlighted the death from war injuries, in light gray those deaths due to avoidable diseases, and in black, deaths caused by other type of causes. This chart does not only deliver quantitative information about deaths, it also signals a substantial problem about the military's health system at that time.

Nightingale's diagram revealed the problem, which was the initial step for a series of reforms. Thus, visualization becomes a tool that can be applied in all stages of investigation. At an initial stage, it is important for the exploration of data, and to understand how variables relate to each other, their distributions and frequencies. When interpreting the data, visualization is useful for displaying possible tendencies or patterns in the data. Finally, visualization is a great tool for the dissemination of knowledge. But remember, with great power comes great responsibility, and spurious relations stop being funny when people take them too seriously^[ Still, it is always entertaining to watch how a correlation exists between [per capita cheese consumption and the number of people strangled to death by their sheets in the United States](http://tylervigen.com/spurious-correlations)!].

@monoganPoliticalAnalysisUsing2015 [ch. 3] had already explained in a simple way for social scientists, why data visualization is important when working with quantitative data. In the introduction of the chapter, Monogan states the importance and the advantages of working with figures, from the simple distribution of variables, outliers or biases, to the trends over time. For this reason, data visualization is a crucial tool for anyone who works with data. It is not, for any reason, an "aesthetic movement"; graphing is extremely useful.

Nonetheless, for some people, data visualization is both a functional element for analysis and an aesthetic element for excellence. For Edward Tufte [-@tufteBeautifulEvidence2006], visualizing data in an effective way has an inevitable artistic component. With statistician formation and a PhD in Political Science from Yale University, Edward Tufte was dedicated to understanding and explaining how science and art have in common an *open-eye observation that generates empirical information*. His book *Beautiful Evidence* [@tufteBeautifulEvidence2006] describes the process of how *watching* is transformed into *showing*, and how empirical observation becomes explanations and evidence. 

We need to understand that data visualization is a language just like any other. As broadcasters, we need to know our audience: who are the receivers of our message, if it is an expert audience or just the general public. In any circumstance, we would adjust our message to the type of audience. The same occurs when we visualize data. The graphs that we make must be adapted to our audience. Yet, even with the most knowledgeable people we should not  get too excited. It is not about applying all we know immediately, but to understand what we are trying to communicate. Understanding the functions of this language is essential.

In the following subsection we will talk about how `ggplot2` works. From now on, we will start with applied examples. The most common types of visual representation are the histogram, the bar graph, the density chart and the line graph. Also, we will introduce other utility packages for making more sophisticated graphs. Finally, we will learn about other packages that can be useful within social sciences, and in particular, political science, as are `sf` and `ggparliament`.

\index{data visualization!ggparliament}

> **Tip:** After this chapter, if you want to learn more about data visualization, check [Data Visualization: A Practical introduction](http://socviz.co) by Kieran Healy, a book available for free that is fun and helpful for learning `ggplot2` step by step. In this book you will not only find a theoretical part, but also a practical one. On the other hand, the web page [From Data to Viz](https://www.data-to-viz.com/) can help you learn how to present your data, but not only that: whether you work with R or Python, you can find the packages and codes for its application.


## First steps

Now that we understand the process before constructing a graph, we have to get familiarized with `ggplot2`, the package to create graphs that is part of the `tidyverse`. [A Layered Grammar of Graphics](https://byrneslab.net/classes/biol607/readings/wickham_layered-grammar.pdf), from Hadley Wickham, explains in detail how this new "grammar" works for making graphs. We recommend that you read from the original source how this package was created to later understand the use of layers in the construction of the graphs.

Although the use of `ggplot2` was rapidly expanded, within the R community there are constant discussions about the teaching of `ggplot2` as a first option over the base R graphs. For example, [David Robinson](http://varianceexplained.org/r/why-I-use-ggplot2/)  has in his blog different entries about this topic, where he explains in detail the advantages of `ggplot2` over other options. If you are a beginner in R, starting with `ggplot2` will give you a powerful tool, and its learning curve is not as steep as base R’s.

Some advantages that David Robinson mentions in "Why I use `ggplot2`"^[http://varianceexplained.org/r/why-I-use-ggplot2/] are:

* Captions! Base R requires more knowledge from the users in order to add captions in graphs. Our friend `ggplot2` does it automatically.
* Faceting! Basically, we can create sub-graphs with a third or fourth variable and overlay them,  which will allow us a better understanding of the behavior of our data.
* It works together with `tidyverse`.  This means that we can make more with less. At the end of this chapter you will understand what I mean. There are shortcuts for everything.
* Aesthetically, it is better. There are thousands of options for chromatic palettes, themes and fonts. If you do not like it, there is a way of changing it.

With this in consideration, let's start with the practical.

### The layers of the "ggplotian multiverse" 

Let's start with our topic of interest: How does `ggplot2` works? This package is included in the `tidyverse`, so it is not necessary to load it separately. Also, we will use tools from both packages throughout the entire chapter. Then, the first step is loading the package:

```{r, message = FALSE}
library(tidyverse)
```

The intuition behind `ggplot2` is straightforward. The construction of the data is based on layers that contain a certain type of information.

#### Data

The first layer corresponds to the data we will use. To make this more demonstrative, we will load the dataset that will be used throughout the chapter.

```{r eval=F}
data("municipal_data")
```

```{r, echo=F, message=F}
municipal_data <- read_rds("00-data/dataviz/data_municipal_v4_eng.rds")
```

The dataset should now be in our environment. This dataset corresponds to information about Chilean municipalities. Some are from the [Electoral Service](http://www.servel.cl) and others from the [National System of Municipal Information](http://datos.sinim.gov.cl/datos_municipales.php) of Chile. In the first dataset, we find electoral results of local, regional and national elections of the country; while in the second we find economic, social and demographic characteristics of the Chilean municipalities. In this case, we have the communal electoral data from 1992 to 2012, with descriptive data such as population, total income of the municipality, social assistance expenditure and the percentage of people living in poverty based on the communal total of the National Socio-economic Characterization Survey (CASEN).

\index{data exploration!dplyr!glimpse()}

```{r}
glimpse(municipal_data)
```

When looking at the dataset, we find that there are continuous (numeric) and categorical (character) variables. Knowing what type of variable we are working with is essential for the next step.

#### Aesthetics

The second layer corresponds to the mapping of the variables within the space. In this step, we use `mapping = aes()`, which will contain the variable we will have on our x-axis and y-axis (Figure \@ref(fig:g1)). For `aes()`,  there are many options we will see throughout the chapter: some of them are, for example, `fill =`, `color =`, `shape =`, and `alpha =`. All these options are a set of signs that will allow us to better translate what we want to say through our graphic. Normally, these options are called *aesthetics* or `aes()`.

\index{data visualization!ggplot2!mapping=aes()}
```{r g1, results='hide', warning=FALSE, fig.align='center', fig.cap="Empty frame plot.", out.width="80%"}
ggplot(data    = municipal_data, 
       mapping = aes(x = year, y = poverty))
```

The result shows an empty frame. This is because we have not told R which geometrical object to use.

#### Geometrical Object

It sounds strange, but when we talk about the geometrical object or "geom", we are referring to the type of graph we want to make, either a line graph, a bar graph, a histogram, a density graph, or a dot graph, or if we want to make a boxplot. This corresponds to the third layer. In this case, since we have data from the CASEN survey, we will make a boxplot to look at how municipalities are distributed in our sample (Figure \@ref(fig:g2)).

\index{data visualization!ggplot2!geom}

```{r g2, results='hide', warning=FALSE, fig.align='center', out.width="80%", fig.cap="Adding a geometric object to your plot."}
ggplot(data    = municipal_data, 
       mapping = aes(x = year, y = poverty)) +
  geom_boxplot()
```

The first thing we notice is the absence of data for three periods. Unfortunately, there is no data before 2002, so no entries are found for those years. Because of this, it is a great idea to filter the data and leave only those years which contain data about the CASEN survey. Besides that, our graph does not tell us much about the percentage of poverty and its distribution. Considering Chile's geography, it is a great idea to see the distribution of poverty by geographical region zone.

#### Faceting

Now, we will use our new skills for doing two things: first, we will use `filter()` to keep only those years we are interested in. Second, we will divide the results by zones using `facet_wrap()`, which corresponds to the fourth layer we can use for building a graph with `ggplot2`. When we use this layer, what we want is to organize the geoms we are using as a function of a categorical variable. In this case, zone. However, *faceting*, as an action, is much more than that. `facet_wrap()` and `facet_grid()` can adopt a series of arguments, the first one being the most important. In this case, the syntax we use is the same used for formulas in R, and we denote the first argument with a "~" sign. With the arguments `nrow =` and `ncol =` we can specify how we want to order our graph.

Finally, we add two lines of code, one for filtering and the other one for subdividing our information. This is what we accomplish (Figure \@ref(fig:g3)):
\index{data visualization!ggplot2!facets}

```{r g3, warning=F, fig.align='center', fig.width = 7, fig.asp = .62, , fig.cap="Adding a facet to your plot."}
ggplot(data    = municipal_data %>% filter(year == c(2004, 2008, 2012)),
       mapping = aes(x = year, y = poverty)) +
  geom_boxplot() +
  facet_wrap(~ zone, nrow = 1)
```

Both with `facet_wrap()` and `facet_grid()` we can use more than one argument, but the results are different. `facet_wrap()` does not only order the geoms, but is capable of crossing them, creating graphs with two or more dimensions using categorical variables. Look at the next examples in Figures \@ref(fig:g4) and \@ref(fig:g5):

```{r g4, warning=F, fig.align='center', fig.cap="Comparing wraps and grids, example A.", fig.height = 6, fig.asp = .9}
ggplot(data    = municipal_data%>% filter(year == c(2004, 2008, 2012)),
       mapping = aes(x = year, y = poverty)) +
  geom_boxplot() +
  facet_wrap(zone ~ gender)
```

```{r g5, warning=F, fig.align='center',fig.width = 7, fig.asp = .78, fig.height=9, fig.cap="Comparing wraps and grids, example B."}
ggplot(data    = municipal_data %>% filter(year == c(2004, 2008, 2012)),
       mapping = aes(x = year, y = poverty)) +
  geom_boxplot() +
  facet_grid(zone ~ gender)
```

This graph shows that, by zone, the percentage of poverty has varied considerably from 2004 to 2012, and that there is a high interregional variability. Furthermore, it shows us how `ggplot2` delivers high-quality results without much complexity. The `facet_wrap()` function is an optional layer within the multiple layers of "A Layered Grammar of Graphics", but it is important to remember that the other three must be present for any type of results.

#### Transformations

Another layer you can use is one that allows us to do scale transformations in the variables (Figure \@ref(fig:g6)). Normally, it will appear with the name `scale_x_discrete()`, which will vary depending on the aesthetic used within our mapping. Thus, we can encounter `scale_fill_continous()` or `scale_y_log10()`. For example, we can see how municipalities’ income is distributed according to the poverty rate of our sample. Usually, we would do this as follows:
\index{data visualization!ggplot2!scales}
```{r g6, warning=F, fig.align='center', fig.cap="Example of a plot in which we do not use scaling."}
ggplot(data    = municipal_data %>% filter(year == c(2004, 2008, 2012)),
       mapping = aes(x = poverty, y = income)) +
  geom_point()
```

Most frequently, when we use a variable related to money, we apply a logarithmic transformation (Figure \@ref(fig:g7)). However, how does this translate into our figure? 

```{r g7, warning=F, fig.align='center',  fig.cap="Example of a plot in which we rescaled the y axis."}
ggplot(data    = municipal_data %>% filter(year == c(2004, 2008, 2012)),
       mapping = aes(x = poverty, y = income)) +
  geom_point() +
  scale_y_log10()
```


#### Coordinate system

Usually, we will work with an x-axis and a y-axis. There are functions in `ggplot2`, such as `coord_flip`, that allow us to change the direction of our graph. However, we can also use this type of layer when working with geographical data, or when, for example, we want to make a pie chart. Although, normally, [we do not want to make pie charts](https://www.datapine.com/blog/common-data-visualization-mistakes/). The more you use `ggplot2`, the more you will learn about each option.

\index{data visualization!ggplot2!coordinates}

#### Themes

When mapping data, we use aesthetic options. When we want to change how a graph looks, we change the theme. You can do this through `theme()`, which allows modifying things that are not related to the content of the graph. For example, the background colors or the font of the letters in the axes. You can also change where the caption or the title will be located. Lastly, you can also change the title, the name on the axes, add annotations, etc. You just need to know `labs()` and `annotate()`.
\index{data visualization!ggplot2!themes}
Now, it is time to apply everything we "apparently" already understand.

## Applied example: Local elections and data visualization

As we previously mentioned, the primary issue is to understand that visualization enables us to explore our data and answer substantive questions of our investigation. Usually, means, standard deviations or another type of parameters do not tell us much. We can express the same data by visualizing it. For example, a boxplot can be useful for representing the distribution of the data and see its possible outliers, while a bar graph can help us to look at the frequency of our categorical data, and a line graph is practical for understanding change over time. These are just some examples within a variety of possibilities.

In this third section, we will learn how to visualize different types of graphs with data from municipal re-election in Chile. To contextualize, the smallest political-administrative division in Chile is the commune or municipality, which every four years chooses its local authorities: a mayor and a municipal council. Since 1992 to 2000, mayors were indirectly elected, and since 2004 they started being elected directly by citizens.

Since we already know our data, we can start with the simplest. A good idea, for example, is to see the number of women elected as mayors compared to the number of men elected. For that, we can use a bar graph (Figure \@ref(fig:g8)). As we learned in the previous section, for constructing any type of graph we need to know the variable(s) that we want to use and what geometry or "geom" allows us to represent it. In this case, we will use `geom_bar()` to see how many men and women were elected since 1992. 

### Graph bar

```{r g8, fig.align='center',  fig.cap="Simple graph bar.", out.width="80%"}
plot_a <- ggplot(municipal_data, mapping = aes(x = gender))

plot_a + 
  geom_bar()
```
\index{data visualization!ggplot2!geom!bar()}
As we can see, constructing a bar graph is an easy task. We see that, from 2004, over 800 men were elected as mayors, a number that exceeds by far the number of women elected for the same charge in the same period.

Perhaps, this number has changed over time, and we cannot see it in this type of graph? This appears to be a good reason for using `facet_wrap` (Figure \@ref(fig:g9)).

```{r g9, fig.align='center', fig.cap="Bar graph with a facet by year."}
plot_a + 
  geom_bar() + 
  facet_wrap(~year, nrow = 1)
```

As we can see, the number of women mayors appears to increase, although it is a much smaller increase than would be expected. This could be a substantive problem for making an analysis of the local government in Chile.

Geometries like `geom_bar()`, `geom_col()`, `geom_density()` and `geom_histogram()` tend not to carry a y-axis explicit in its aesthetics, since they are a count on the x-axis. Nonetheless, one can modify the y-axis in these geometries by applying some type of transformation. For example, when specifying `y = ..prop..` as an aesthetic within the geometrical object, we are commanding the calculus of the proportion, not the count. Normally, we will use `aes()` in addition to the data in `ggplot()`, but depending on your preferences, it is also possible to use it with geoms. The latter is more common when we occupy more than one dataset or when we want to do a transformation.

For example, we could be interested in the number of local authorities per geographical zone. For that, it would be helpful to use a proportion, since every geographical zone is made up of a different number of municipalities. By doing this, comparing the situation between zones will be easier (Figure \@ref(fig:g10)).

```{r g10, fig.align='center',fig.width = 4.9, fig.height=3.3, , out.width="80%", fig.cap="Bar graph with a facet by zone."}
plot_a + 
  geom_bar(mapping = aes(y = ..prop.., group = 1)) +
  facet_wrap(~zone, nrow = 1)
```

But why do we use `group = 1`?
\index{data visualization!ggplot2!group}
When we want to calculate a proportion with `y = ..prop..`, we have to take some precautions if we are using `facet_wrap`. This function does not calculate the proportion based on the sum of both genders by zone. For example, this function registers that there are 89 elected men and 13 elected women in the Upper North zone. It concludes that "in the Upper North, the 89 men correspond to 100% of elected men, and the 13 women correspond to 100% of elected women". Clearly, this is not what we are trying to represent in the graph. This is why we use `group=1`. Try to see the result without `group=1` to check out what happens.

We have done it! We see that there are no big differences, where the "Lower North" zone is the one with more women in the mayor office than men. Nonetheless, there are no major differences between zones, and the results from the first bar graph are replicated in this one.

Now, we can change the graph’s presentation. Every good graph must contain, for example, an clear title, the source of the data and the detail of the axes (Figure \@ref(fig:g11)). 

> **Suggestion.** The *Chicago Guide to Writing about Multivariate Analysis* [@millerChicagoGuideWriting2013] has lots of good advice on how to create effective charts.

```{r g11, fig.align='center', fig.width = 6, fig.height=3.8, fig.cap="Bar graph with title and sources."}
plot_a + 
  geom_bar(mapping = aes(y = ..prop.., group = 1)) +
  facet_wrap(~zone, nrow = 1) +
  labs(title = "Proportion of men and women elected as mayors (2004-2012)",
       subtitle = "By economic zones of Chile",
       x = "Gender", y = "Proportion", 
       caption = "Source: Based on data from SERVEL and SINIM (2018)") 
```

Now, we only need to add labels for the x-axis (Figure \@ref(fig:g12)). We can easily do this with `scale_x_discrete()`. You have to consider which aesthetic from `aes()` you will modify, since this will change the `scale =` you need. If we were to examine labels from `fill =`, for example, we would have to use `scale_fill_discrete()`. You also have to take into account the type of variable you are using. `scale_x_discrete()` does not have "discrete" at the end for no reason. As you will comprehend, it depends totally on the type of variable we are using.

```{r g12, fig.align='center',fig.width = 6, fig.height=3.8, fig.cap="Plot with group labels."}
plot_a + 
  geom_bar(mapping = aes(y = ..prop.., group = 1)) +
  facet_wrap(~zone, nrow = 1) +
  scale_x_discrete(labels = c("Men", "Women")) +
  labs(title = "Proportion of men and women elected as mayors (2004-2012)",
       subtitle = "By economic zones of Chile",
       x = "Gender", y = "Proportion", 
       caption = "Source: Based on data from SERVEL and SINIM (2018)") 
```

>**Tip.** With `labels =` we can change the labels. Consider the number of values in your categorical variable so that they match the variable, and you do not miss any category.

### Line graph

In the last graph of the previous section we saw that, although the election of women as mayors in Chile has risen, this rise appears to not be significant: in 2012, only 13% of elected mayors were women. Perhaps this may be because socio-economic changes have not affected perceptions of gender roles in society. Looking at the economic data from municipal income or the percentage of poverty according to the CASEN might help us understand why women's election in municipal instances has not increased substantially. For this, we can use `geom_line()`, the geometric object that permits watching the evolution over time of our subject of interest (Figure \@ref(fig:g13)). The intuition would be to make the figure this way:

```{r g13, fig.align='center', fig.width=3.5, fig.cap="A wrong specification for a line graph."}
plot_b <- ggplot(data    = municipal_data, 
                 mapping = aes(x = year, y = income)) 

plot_b + 
  geom_line()
```

The problem is that it does not deliver the expected result. The intuition is correct, but we have to help `geom_line()` with some specifications. In this case, it groups by what it makes the most sense: by year. For this reason, we have to specify which is the variable that groups all the information and, as we know, the information we possess is grouped by municipality. When we add this information, the result changes and it resembles what we are looking for (Figure \@ref(fig:g14)):

```{r g14, fig.align='center', warning=F, fig.cap="Yearly evolution of income by municipality."}
plot_b + 
  geom_line(mapping = aes(group = municipality))
```
\index{data visualization!ggplot2!geom!line()}
One of the issues that emerges at first glance is that, considering that Chile has 345 municipalities, it appears impossible to display them all in just one graph.

Now, we can separate the graph as we have done before. It can be done by zones or regions, considering your interests (Figure \@ref(fig:g15)). We have already seen different results by zone, so it would be worthwhile to see the income in the same way:

```{r include=F}
theme_set(cowplot::theme_cowplot(font_size = 18, 
                                 font_family = "Latin Modern Roman") +
            theme(legend.position = "top",
                  legend.justification = "right",
                  legend.key.size =  unit(0.2, "inches"),
                  legend.margin = margin(0, 0, 0, 0),
                  legend.box.margin = margin(-5, 10, -10, -10)))
```


```{r g15, fig.align='center', warning=F, fig.width=10,fig.height=8, fig.cap="Yearly evolution of income by municipality faceted by zone."}
plot_b + 
  geom_line(aes(group = municipality)) +
  facet_wrap(~zone, nrow = 2)
```

Since our sample is composed of a small number of years, we are not able to see much variability and, at first glance, the income of all municipalities has incremented considerably. Perhaps, we can still make some adjustments to our graph. Most likely, you are not familiar with scientific notation and you are better off reading big numbers. Perhaps you know that it is better to work with a monetary variable in its logarithmic transformation, as we have been taught in different courses of methodology. In addition, you may want to add another type of information into this graph, for example, the means (Figure \@ref(fig:g16)).

What do you think about this graph? 

```{r g16, fig.align='left', fig.width=10, fig.height=8, warning=F, fig.cap="Complete version of our line graph for municipality income in electoral years."}
means <- municipal_data %>% 
  group_by(zone) %>% 
  summarize(mean = mean(income, na.rm = T))

plot_b + 
  geom_line(color = "lightgray", aes(group = municipality)) +
  geom_hline(aes(yintercept = mean), data = means, color = "black") +
  scale_x_discrete(expand = c(0,0)) +
  scale_y_log10(labels = scales::dollar) +
  facet_wrap(~ zone, nrow = 2) +
  labs(title = "Municipal income in electoral years (2004-2012)",
       y = "Income",
       x = "Years") +
  theme(panel.spacing = unit(2, "lines"))
```

What did we specify?

1. First, we created a dataset ("mean") that contains the mean income by every zone. We did this by using `group_by()` and `summarize()` of the `tidyverse`.

```{r}
municipal_data %>% 
  group_by(zone) %>% 
  summarize(mean = mean(income, na.rm = T))
```

2. Then, we specify the color of the `geom_line()`.

3. After that, we add to our code `geom_hline()`.  This geometrical object, like `geom_vline()` or `geom_abline()`, allows us to add lines with information. In this case, I used it to add the mean income of every zone. We specify the variable that contains the means `yintercept = mean`, the dataset `means`, and the color with `color = "black"`.

4. Following that, we use `scale_x_discrete()` to specify the expansion of the panels. If before we previously saw a grey space without information, we removed it. This is aesthetic.

5. Then, we use `scale_x_discrete()` to scale our data. This is a logarithmic transformation that is usually done when we work with linear models that contain monetary data. Also, we changed the labels of the y-axis: it no longer appears with scientific notation. This was done with a package called `scales`. Here we call the function directly with `scales::dollar`.

6. We add the title and names of the x and y axes with `labs()`.

7. Finally, we specify information about the theme. Without it, the years between one panel and another would crash. For that, we specify it with `panel.spacing = unit(2, "lines")` in the `theme()` layer.

### Boxplot

We already saw that the income of the municipalities in Chile increased between 2004 and 2012. While we looked at the graph without functional transformations, we noted that some municipalities had incomes well above the average and stood out within their zones. The intuition is that they are probably *outliers*. We could see this clearly with a boxplot, which allows us to graph diverse descriptive data in our variables such as the median, minimum and maximum. In this case, we will use it to observe if our intuition is correct or not^[Chapter \@ref(maps) will be very useful if you wish to detect outliers through maps.].

Let's start by filtering the data as we did in the previous graph. In our x-axis we will place the zones of Chile and in the y-axis the income. This is the result we will work with (Figure \@ref(fig:g17)):

\index{data visualization!ggplot2!geom!boxplot()}
```{r g17, warning=F, fig.align='center', fig.height=9.5, fig.width=11, fig.cap="Boxplot of municipality income per zone, faceted by year."}
plot_c <- ggplot(data    = municipal_data %>% 
                   filter(year %in% c(2004, 2008, 2012)),
                 mapping = aes(x = income, y = zone)) +
  geom_boxplot() +
  facet_wrap(~year, ncol = 1)

plot_c
```

We can clearly observe some *outliers*. Perhaps, after looking at these results, we would like to identify which municipalities receive the highest total income. For this, we can use the aesthetic `label =`, which is included in `geom_text()`. For naming just the outliers, we have to make a subset of data (Figure \@ref(fig:g19)):

```{r g18, fig.align='center', warning=F, fig.height=8.5, fig.width=11, fig.cap="Through the use of labels a boxplot can be usefull to identify outliers.", eval=F}
plot_c + 
  geom_text(data    = municipal_data %>% filter(income > 50000000),
            mapping = aes(label = municipality))
```

```{r g19, fig.align='center', warning=F, fig.height=9.5, fig.width=11, fig.cap="Through the use of labels a boxplot can be usefull to identify outliers.", echo=F}
plot_c + 
  geom_text(data    = municipal_data %>% filter(income > 50000000),
            mapping = aes(label = municipality),
            family = "Latin Modern Roman", size = 5)
```

Unfortunately, the labels are over the points, and, in some cases, these overlap when these are close to each other. We can solve this with the package `ggrepel`, which has an "improved" `geom_text()` geometric element that avoids the coalition of the labels.
\index{data visualization!ggrepel}

```{r eval=F}
library(ggrepel)

plot_c + 
  geom_text_repel(data    = municipal_data %>% 
                    filter(income > 50000000),
                  mapping = aes(label = municipality))
```

```{r g20, warning=FALSE, fig.align='center', fig.height=9.5, fig.width=11, fig.cap="We can fix overlapping labels using ggrepel.", echo=F}
library(ggrepel)

plot_c + 
  geom_text_repel(data    = municipal_data %>% 
                    filter(income > 50000000),
                  mapping = aes(label = municipality),
                  family = "Latin Modern Roman", size = 5, seed = 123)
```

The cut-off can be at $50,000,000 or at greater or smaller numbers (Figure \@ref(fig:g20)). It depends entirely on what we want to observe. Furthermore, with `geom_text()` or `geom_text_repel()` we can not only change the color, but also the type of font of the text, or if it should be in bold, italic or underlined. To see more options, you can type `?geom_text` or call a `help("geom_text")`.

We could also add other information or change the current way the graph is presented (Figure \@ref(fig:g22)).

```{r g21, fig.height=8.5, fig.width=11, fig.align='center', warning=F, fig.cap="Polished version of our boxplot.", eval=F}
plot_c + 
  geom_text_repel(data = municipal_data %>% 
                    filter(income > 50000000), 
                  mapping = aes(label = municipality)) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "Municipal income by zone (2004-2012)",
       x = "Income", y = "Zone", 
       caption = "Source: Based on data from SINIM (2018)")
```

```{r g22, fig.height=9.5, fig.width=11, fig.align='center', warning=F, fig.cap="Polished version of our boxplot.", echo=F}
set.seed(1); plot_c + 
  geom_text_repel(data = municipal_data %>% 
                    filter(income > 50000000), 
                  mapping = aes(label = municipality),
                  family = "Latin Modern Roman", size = 5, seed = 123) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "Municipal income by zone (2004-2012)",
       x = "Income", y = "Zone", 
       caption = "Source: Based on data from SINIM (2018)")
```

```{r include=F}
source("_before.R")
```

Some other specifications:
1. We added the descriptive information into the graph.
2. We changed the font size. This was important because of the number of municipalities that are above $50,000,000 in income.
3. Again, we changed the y-axis labels with `scales::dollar`.
4. Lastly, with `guides`, and specifying the `aes()` we wanted to address, we wrote the code `color=F` to remove the label, since it was repeated information within the graph.

\index{exercise!03A@3A. data visualization}

> **Exercise 3A.** We invite you to play with `geom_text()`: change the colors, size, fonts, etc. We also encourage you to install packages that will allow you to further customize your graphics: `ggthemes` from [jrnorl](https://github.com/jrnold/ggthemes) has themes for graphs from programs and well-known magazines such as Excel or The Economist. On the other hand, `hrbrthemes` from [hrbrmstr](https://github.com/hrbrmstr/hrbrthemes) has elaborated some minimalist and elegant themes that will make all your graphs look better. If you are into colors, you can check the `wespalette` package from [karthik](https://github.com/karthik/wesanderson), a chromatic palette based on Wes Anderson movies, or create your own palettes based on images with `colorfindr`. You can find more about the latter in the following [link](https://github.com/zumbov2/colorfindr).


### Histogram

As we observed in our boxplot, many municipalities--especially those in the central zone--are well above the median income per zone. We can see the distribution of this data through a histogram. Constructing a histogram is an easy task, and as previously mentioned, `geom_histogram()` does not have an explicit y-axis, since it counts the frequency of an event within an interval.

When creating the histogram according to our intuition, the result is as follows (Figure \@ref(fig:g23)):

```{r g23, message = F, fig.align='center', fig.cap="Simplest version of a histogram of the municipality's tax income."}
ggplot(data    = municipal_data, 
       mapping = aes(x = income)) +
  geom_histogram()
```
\index{data visualization!ggplot!geom!histogram()}
As we can see, the graph gives a "Warning" that indicates the existence of "rows that contain non-finite values". This warning has been present throughout this chapter, and it means nothing more than "There  are unknown values within this variable" and it is because there is no data for the first years. So do not worry, if we filter the data with `filter(!is.na(income))`, this warning will surely disappear.

Also, the console gives the following message: `stat_bin()` using `bins = 30`. Pick better values with `binwidth`. Simply, it says that it is possible to modify the intervals for the histogram.

The following step is to modify the x-axis. Personally, I have never been good at reading numbers with scientific notation. On the other side, we will try changing the number of intervals with `bins` (Figure \@ref(fig:g24)).

```{r g24, fig.align='center', fig.cap="Histogram of municipality's tax income with a corrected scale in x."}
ggplot(data    = municipal_data,  
       mapping = aes(x = income)) +
  geom_histogram(bins = 50) +
  scale_x_continuous(labels = scales::dollar) 
```

\index{exercise!03B@3B. data visualization}

> **Exercise 3B.** What happens if we put `bins = 15` intervals?

Next we will make a subset of the data. Considering the number of outliers we found, we will eliminate the municipalities that have incomes above $50,000,000. Also, we will use another type of aesthetic: `fill =`, which will help us identify each zone by color^[The colors don't translate well to grayscale, of course. You should see them if you are running the code yourself!]. Aesthetic properties such as `fill =`, `color =`, `size =`, change when they are used with discrete or continuous variables (Figure \@ref(fig:g26)).

```{r include=F}
theme_set(cowplot::theme_cowplot(font_size = 16, 
                                 font_family = "Latin Modern Roman") +
            theme(legend.position = "top",
                  legend.justification = "right",
                  legend.key.size =  unit(0.2, "inches"),
                  legend.margin = margin(0, 0, 0, 0),
                  legend.box.margin = margin(-5, 10, -10, -10)))
```

```{r g25, warning=F, fig.align='center', fig.height = 6, fig.width = 10, fig.cap="Polished version of our histogram in which we 'fill' by zone.", eval=F}
ggplot(data    = municipal_data %>% filter(income < 50000000), 
       mapping = aes(x = income, fill = zone)) +
  geom_histogram(alpha = 0.5, bins = 50) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "Number of municipalities according to their annual income",
       subtitle = "Chile (2004-2012)",
       x = "Income", y = "Number of municipalities", 
       caption = "Source: Based on data from SINIM (2018)")
```

```{r g26, warning=F, fig.align='center', fig.height = 6, fig.width = 10, fig.cap="Polished version of our histogram in which we 'fill' by zone", echo=F}
ggplot(data    = municipal_data %>% filter(income < 50000000), 
       mapping = aes(x = income, fill = zone)) +
  geom_histogram(alpha = 0.5, bins = 50) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "Number of municipalities according to their annual income",
       subtitle = "Chile (2004-2012)",
       x = "Income", y = "Number of municipalities", 
       caption = "Source: Based on data from SINIM (2018)") +
  scale_fill_grey()
```

```{r include=F}
source("_before.R")
```

### Relation between variables

It is likely that one of your biggest concerns is whether the two variables you are studying are related in any way. With `ggplot2` this is easy to verify. In this case, we have two continuous variables: the poverty rate, from the CASEN dataset, and the municipal income. Following the theory, there should be some kind of correlation: the higher the municipal income, the lower the poverty rate in the municipality. We create our empty plot:

```{r g27, warning=F, fig.cap="Choosing the variables to plot their linear relationship."}
plot_f <- ggplot(data    = municipal_data, 
                 mapping = aes(x = poverty, y = log(income)))
```

For this type of graph, we will use `geom_smooth()`. With this object, you can modify the way in which the variables relate with `method`. You can also introduce your own formulas. By default, a linear relation between variables comes specified, so it is not necessary to write it (Figure \@ref(fig:g28)).
\index{data visualization!ggplot!geom!smooth()}
```{r g28,  fig.align='center', warning=F, fig.cap="Linear fit of povery on the log of income."}
plot_f + 
  geom_smooth(method = "lm", color = "black") 
```

It looks empty, doesn't it? Normally, we use `geom_smooth()` with other geometric figures, as `geom_point()`, to indicate the position of the columns within space. We use `alpha` to see the overlapping of the points. As they are not too many, there are no problems in seeing how they are distributed (Figure \@ref(fig:g29)).
\index{data visualization!ggplot!geom!point()}

```{r g29,  fig.align='center', warning=F, fig.cap="Linear fit plus the scattered observations."}
plot_f + 
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", color = "black") 
```

Now we can make two improvements. First, we will insert the title and the name of the axes. Second, in `scale_x_continuous()` we will specify where our graph starts and ends. We had already used this with `geom_line()` (Figure \@ref(fig:g30)).

```{r g30,  fig.align='center', warning=F, fig.width=7.4,  fig.height=5, fig.cap="Polished version of our linear fit plot."}
plot_f + 
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", color = "black") +
  scale_x_continuous(expand = c(0,0)) +
  labs(title = "Relation between municipality income and its poverty rate",
       subtitle = "Chile (2004-2012)", 
       x = "CASEN’s poverty rate", y = "Income", 
       caption = "Source: Based on data from SINIM (2018)") 
```

Clearly, there is a negative correlation between both variables. This is what we expected! Now, we can calculate the correlation between both variables, to be more certain of the results obtained visually:

```{r}
cor(municipal_data $poverty, municipal_data$income, 
    use = "pairwise.complete.obs")
```

The correlation between both variables is -0.27. It would be interesting to add this information into the graph. We can do this with `annotate()`. We just need to specify the type of geometric object we want to generate. In this case, what we want to create is text `geom = "text"`, but it could be a box highlighting a specific point in the graph `geom = "rect"`  or a  line `geom = "segment"`. We specify where we want to locate it and, finally, annotate what we want to annotate (Figure \@ref(fig:g31)).
\index{data visualization!ggplot!annotate()}
```{r g31, fig.align='center', warning=F, fig.width=7.4,  fig.height=5, fig.cap="We add the correlation coeficient using 'annotate'."}
plot_f + 
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", color = "black") +
  scale_x_continuous(expand = c(0, 0)) +
  labs(
    title = "Relation between municipality income and CASEN’s poverty rate", 
    subtitle = "Chile (2004-2012)", 
    x = "CASEN’s poverty rate ", y = "Income", 
    caption = "Source: Based on data from SINIM (2018)") +
  annotate(geom = "text", x = 50, y = 15, label = "Correlation: -0.27")
```

## To continue learning

There are many roads for visualizing your data. In this entry, you learned the main functions from `ggplot2`, a package within `tidyverse`, but there are many more packages that can be of great help for other types of visualizations.  Although `ggplot2` may not have all the geometrical objects you need, there are packages for visualizing other types of data that work under `ggplot2` and the layers that constitute its "grammatical" form. 

### Other packages

#### `sf` 
\index{data visualization!data visualization!sf}
It allows to visualize spatial elements. For `ggplot2` it works with `geom_sf()`. It enables the creation of geometric figures with different types of spatial data. In Chapter \@ref(maps)  of spatial data, Andrea and Gabriel deliver the tools to work with `sf`, its main functions and directrices. [Here](https://github.com/r-spatial/sf) you can find more details about how to install it and its performance depending on your computer.

#### `ggparliament`
\index{data visualization!ggparliament}

All political scientists should know this package. It allows you to visualize the composition of the legislative power. It is a dream for those who work with this type of information. It enables you to specify the number of seats, the color of each party, and add different characteristics to your graph. [Here](https://github.com/RobWHickman/ggparliament) you can find more details about the tools from `ggparliament` (Figure \@ref(fig:ggparl)).

(ref:ggparl) Example of a plot built using ggparliament with data from the Mexican Parliament. Source: \@leonugo, Twitter.

```{r ggparl, echo=F, out.width="80%", fig.cap='(ref:ggparl)'}
knitr::include_graphics("00-images/dataviz/tweet_ggparl.png")
```

#### `ggraph`
\index{data visualization!ggraph}
If you study networks and you know how `ggplot2` works, this package can become your new best friend. It is made for all types of relational data, and even though it works under the `ggplot2` logic, it has its own geometric objects, *facets*, among others. [Here](https://github.com/thomasp85/ggraph) you can find more information. In Chapter \@ref(networks) Andres will show you how to use this package in depth.

#### `patchwork` 

\index{data visualization!patchwork}
This is a great tool to combine separate ggplots into the same graphic. You will use `+`, `|` and `/` to arrange them (Figure \@ref(fig:patch)):

```{r patch, fig.align='center', warning=F, fig.width=7.4,  fig.height=8, fig.cap="Patchwork example."}
plot_a2 <- plot_a + 
  geom_bar()

plot_b2 <- plot_b +
  geom_line(mapping = aes(group = municipality))

library(patchwork)
(plot_a2 | plot_b2) / plot_c
```


You already know how to make graphs and, as basic as it may appear, you now have numerous tools to keep working. However, there are some things we did not addressed:


\index{exercise!03C@3C-E. data visualization}

> **Exercise 3C.** We already learned how to make a histogram, yet, density charts tend to be more used for looking at the distribution of one variable. Using the same variables, make a density chart with `geom_density()`.
>
> **Exercise 3D.** Usually, bar graphs are presented with the frequency or proportion within the bar. We can also do this with `ggplot2`. Using `geom_bar()` and `geom_text()`, note the number of mayors by geographical area. A tip: you have to do some calculus with `tidyverse` before adding that information into the plot.
>
> **Exercise 3E.** Choosing only one year, make a line graph with `geom_smooth()` that indicates the relation between income and poverty rate. Now, with `annotate()`, make a box that encloses the municipalities with the highest poverty rate and, above it, write down the corresponding municipality.
